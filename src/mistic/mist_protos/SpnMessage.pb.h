// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SpnMessage.proto

#ifndef PROTOBUF_SpnMessage_2eproto__INCLUDED
#define PROTOBUF_SpnMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace trendmicro {
namespace spn {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SpnMessage_2eproto();
void protobuf_AssignDesc_SpnMessage_2eproto();
void protobuf_ShutdownFile_SpnMessage_2eproto();

class Timestamp;
class OutOfBandObject;
class Link;
class MessageBase;
class Message;
class MessageList;
class ContainerBase;
class LogInfo;
class Container;

// ===================================================================

class Timestamp : public ::google::protobuf::Message {
 public:
  Timestamp();
  virtual ~Timestamp();
  
  Timestamp(const Timestamp& from);
  
  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();
  
  void Swap(Timestamp* other);
  
  // implements Message ----------------------------------------------
  
  Timestamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.Timestamp)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static Timestamp* default_instance_;
};
// -------------------------------------------------------------------

class OutOfBandObject : public ::google::protobuf::Message {
 public:
  OutOfBandObject();
  virtual ~OutOfBandObject();
  
  OutOfBandObject(const OutOfBandObject& from);
  
  inline OutOfBandObject& operator=(const OutOfBandObject& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OutOfBandObject& default_instance();
  
  void Swap(OutOfBandObject* other);
  
  // implements Message ----------------------------------------------
  
  OutOfBandObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutOfBandObject& from);
  void MergeFrom(const OutOfBandObject& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // required .com.trendmicro.spn.proto.Timestamp expire = 2;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 2;
  inline const ::com::trendmicro::spn::proto::Timestamp& expire() const;
  inline ::com::trendmicro::spn::proto::Timestamp* mutable_expire();
  inline ::com::trendmicro::spn::proto::Timestamp* release_expire();
  
  // optional string sha1 = 3;
  inline bool has_sha1() const;
  inline void clear_sha1();
  static const int kSha1FieldNumber = 3;
  inline const ::std::string& sha1() const;
  inline void set_sha1(const ::std::string& value);
  inline void set_sha1(const char* value);
  inline void set_sha1(const char* value, size_t size);
  inline ::std::string* mutable_sha1();
  inline ::std::string* release_sha1();
  
  // optional string mime_type = 4;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 4;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  inline ::std::string* release_mime_type();
  
  // optional int64 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.OutOfBandObject)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_sha1();
  inline void clear_has_sha1();
  inline void set_has_mime_type();
  inline void clear_has_mime_type();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* url_;
  ::com::trendmicro::spn::proto::Timestamp* expire_;
  ::std::string* sha1_;
  ::std::string* mime_type_;
  ::google::protobuf::int64 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static OutOfBandObject* default_instance_;
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message {
 public:
  Link();
  virtual ~Link();
  
  Link(const Link& from);
  
  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();
  
  void Swap(Link* other);
  
  // implements Message ----------------------------------------------
  
  Link* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // required bytes subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const void* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.Link)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_subject();
  inline void clear_has_subject();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* type_;
  ::std::string* subject_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static Link* default_instance_;
};
// -------------------------------------------------------------------

class MessageBase : public ::google::protobuf::Message {
 public:
  MessageBase();
  virtual ~MessageBase();
  
  MessageBase(const MessageBase& from);
  
  inline MessageBase& operator=(const MessageBase& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageBase& default_instance();
  
  void Swap(MessageBase* other);
  
  // implements Message ----------------------------------------------
  
  MessageBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageBase& from);
  void MergeFrom(const MessageBase& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes subject = 1;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 1;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const void* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  
  // repeated .com.trendmicro.spn.proto.Link prev_link = 2;
  inline int prev_link_size() const;
  inline void clear_prev_link();
  static const int kPrevLinkFieldNumber = 2;
  inline const ::com::trendmicro::spn::proto::Link& prev_link(int index) const;
  inline ::com::trendmicro::spn::proto::Link* mutable_prev_link(int index);
  inline ::com::trendmicro::spn::proto::Link* add_prev_link();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >&
      prev_link() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >*
      mutable_prev_link();
  
  // repeated .com.trendmicro.spn.proto.Link next_link = 3;
  inline int next_link_size() const;
  inline void clear_next_link();
  static const int kNextLinkFieldNumber = 3;
  inline const ::com::trendmicro::spn::proto::Link& next_link(int index) const;
  inline ::com::trendmicro::spn::proto::Link* mutable_next_link(int index);
  inline ::com::trendmicro::spn::proto::Link* add_next_link();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >&
      next_link() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >*
      mutable_next_link();
  
  // repeated .com.trendmicro.spn.proto.OutOfBandObject attachments = 4;
  inline int attachments_size() const;
  inline void clear_attachments();
  static const int kAttachmentsFieldNumber = 4;
  inline const ::com::trendmicro::spn::proto::OutOfBandObject& attachments(int index) const;
  inline ::com::trendmicro::spn::proto::OutOfBandObject* mutable_attachments(int index);
  inline ::com::trendmicro::spn::proto::OutOfBandObject* add_attachments();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::OutOfBandObject >&
      attachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::OutOfBandObject >*
      mutable_attachments();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.MessageBase)
 private:
  inline void set_has_subject();
  inline void clear_has_subject();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* subject_;
  ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link > prev_link_;
  ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link > next_link_;
  ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::OutOfBandObject > attachments_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static MessageBase* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.trendmicro.spn.proto.MessageBase msg_base = 1;
  inline bool has_msg_base() const;
  inline void clear_msg_base();
  static const int kMsgBaseFieldNumber = 1;
  inline const ::com::trendmicro::spn::proto::MessageBase& msg_base() const;
  inline ::com::trendmicro::spn::proto::MessageBase* mutable_msg_base();
  inline ::com::trendmicro::spn::proto::MessageBase* release_msg_base();
  
  // optional bytes derived = 2;
  inline bool has_derived() const;
  inline void clear_derived();
  static const int kDerivedFieldNumber = 2;
  inline const ::std::string& derived() const;
  inline void set_derived(const ::std::string& value);
  inline void set_derived(const char* value);
  inline void set_derived(const void* value, size_t size);
  inline ::std::string* mutable_derived();
  inline ::std::string* release_derived();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.Message)
 private:
  inline void set_has_msg_base();
  inline void clear_has_msg_base();
  inline void set_has_derived();
  inline void clear_has_derived();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::trendmicro::spn::proto::MessageBase* msg_base_;
  ::std::string* derived_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class MessageList : public ::google::protobuf::Message {
 public:
  MessageList();
  virtual ~MessageList();
  
  MessageList(const MessageList& from);
  
  inline MessageList& operator=(const MessageList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageList& default_instance();
  
  void Swap(MessageList* other);
  
  // implements Message ----------------------------------------------
  
  MessageList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageList& from);
  void MergeFrom(const MessageList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.trendmicro.spn.proto.Message messages = 1;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 1;
  inline const ::com::trendmicro::spn::proto::Message& messages(int index) const;
  inline ::com::trendmicro::spn::proto::Message* mutable_messages(int index);
  inline ::com::trendmicro::spn::proto::Message* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Message >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Message >*
      mutable_messages();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.MessageList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Message > messages_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static MessageList* default_instance_;
};
// -------------------------------------------------------------------

class ContainerBase : public ::google::protobuf::Message {
 public:
  ContainerBase();
  virtual ~ContainerBase();
  
  ContainerBase(const ContainerBase& from);
  
  inline ContainerBase& operator=(const ContainerBase& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerBase& default_instance();
  
  void Swap(ContainerBase* other);
  
  // implements Message ----------------------------------------------
  
  ContainerBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerBase& from);
  void MergeFrom(const ContainerBase& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional string reply_to = 2;
  inline bool has_reply_to() const;
  inline void clear_reply_to();
  static const int kReplyToFieldNumber = 2;
  inline const ::std::string& reply_to() const;
  inline void set_reply_to(const ::std::string& value);
  inline void set_reply_to(const char* value);
  inline void set_reply_to(const char* value, size_t size);
  inline ::std::string* mutable_reply_to();
  inline ::std::string* release_reply_to();
  
  // optional .com.trendmicro.spn.proto.MessageList message_list = 3;
  inline bool has_message_list() const;
  inline void clear_message_list();
  static const int kMessageListFieldNumber = 3;
  inline const ::com::trendmicro::spn::proto::MessageList& message_list() const;
  inline ::com::trendmicro::spn::proto::MessageList* mutable_message_list();
  inline ::com::trendmicro::spn::proto::MessageList* release_message_list();
  
  // optional .com.trendmicro.spn.proto.OutOfBandObject message_list_ref = 4;
  inline bool has_message_list_ref() const;
  inline void clear_message_list_ref();
  static const int kMessageListRefFieldNumber = 4;
  inline const ::com::trendmicro::spn::proto::OutOfBandObject& message_list_ref() const;
  inline ::com::trendmicro::spn::proto::OutOfBandObject* mutable_message_list_ref();
  inline ::com::trendmicro::spn::proto::OutOfBandObject* release_message_list_ref();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.ContainerBase)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_reply_to();
  inline void clear_has_reply_to();
  inline void set_has_message_list();
  inline void clear_has_message_list();
  inline void set_has_message_list_ref();
  inline void clear_has_message_list_ref();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* reply_to_;
  ::com::trendmicro::spn::proto::MessageList* message_list_;
  ::com::trendmicro::spn::proto::OutOfBandObject* message_list_ref_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ContainerBase* default_instance_;
};
// -------------------------------------------------------------------

class LogInfo : public ::google::protobuf::Message {
 public:
  LogInfo();
  virtual ~LogInfo();
  
  LogInfo(const LogInfo& from);
  
  inline LogInfo& operator=(const LogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInfo& default_instance();
  
  void Swap(LogInfo* other);
  
  // implements Message ----------------------------------------------
  
  LogInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInfo& from);
  void MergeFrom(const LogInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // required int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // required string original_exchange = 4;
  inline bool has_original_exchange() const;
  inline void clear_original_exchange();
  static const int kOriginalExchangeFieldNumber = 4;
  inline const ::std::string& original_exchange() const;
  inline void set_original_exchange(const ::std::string& value);
  inline void set_original_exchange(const char* value);
  inline void set_original_exchange(const char* value, size_t size);
  inline ::std::string* mutable_original_exchange();
  inline ::std::string* release_original_exchange();
  
  // required string event = 5;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 5;
  inline const ::std::string& event() const;
  inline void set_event(const ::std::string& value);
  inline void set_event(const char* value);
  inline void set_event(const char* value, size_t size);
  inline ::std::string* mutable_event();
  inline ::std::string* release_event();
  
  // required string prefix = 6;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 6;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.LogInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_original_exchange();
  inline void clear_has_original_exchange();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_prefix();
  inline void clear_has_prefix();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* type_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* original_exchange_;
  ::std::string* event_;
  ::std::string* prefix_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static LogInfo* default_instance_;
};
// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();
  
  Container(const Container& from);
  
  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();
  
  void Swap(Container* other);
  
  // implements Message ----------------------------------------------
  
  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.trendmicro.spn.proto.ContainerBase container_base = 1;
  inline bool has_container_base() const;
  inline void clear_container_base();
  static const int kContainerBaseFieldNumber = 1;
  inline const ::com::trendmicro::spn::proto::ContainerBase& container_base() const;
  inline ::com::trendmicro::spn::proto::ContainerBase* mutable_container_base();
  inline ::com::trendmicro::spn::proto::ContainerBase* release_container_base();
  
  // optional bytes derived = 2;
  inline bool has_derived() const;
  inline void clear_derived();
  static const int kDerivedFieldNumber = 2;
  inline const ::std::string& derived() const;
  inline void set_derived(const ::std::string& value);
  inline void set_derived(const char* value);
  inline void set_derived(const void* value, size_t size);
  inline ::std::string* mutable_derived();
  inline ::std::string* release_derived();
  
  // optional .com.trendmicro.spn.proto.LogInfo log_info = 3;
  inline bool has_log_info() const;
  inline void clear_log_info();
  static const int kLogInfoFieldNumber = 3;
  inline const ::com::trendmicro::spn::proto::LogInfo& log_info() const;
  inline ::com::trendmicro::spn::proto::LogInfo* mutable_log_info();
  inline ::com::trendmicro::spn::proto::LogInfo* release_log_info();
  
  // @@protoc_insertion_point(class_scope:com.trendmicro.spn.proto.Container)
 private:
  inline void set_has_container_base();
  inline void clear_has_container_base();
  inline void set_has_derived();
  inline void clear_has_derived();
  inline void set_has_log_info();
  inline void clear_has_log_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::trendmicro::spn::proto::ContainerBase* container_base_;
  ::std::string* derived_;
  ::com::trendmicro::spn::proto::LogInfo* log_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_SpnMessage_2eproto();
  friend void protobuf_AssignDesc_SpnMessage_2eproto();
  friend void protobuf_ShutdownFile_SpnMessage_2eproto();
  
  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// ===================================================================


// ===================================================================

// Timestamp

// required int64 time = 1;
inline bool Timestamp::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamp::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timestamp::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timestamp::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Timestamp::time() const {
  return time_;
}
inline void Timestamp::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// OutOfBandObject

// required string url = 1;
inline bool OutOfBandObject::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutOfBandObject::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutOfBandObject::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutOfBandObject::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& OutOfBandObject::url() const {
  return *url_;
}
inline void OutOfBandObject::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void OutOfBandObject::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void OutOfBandObject::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutOfBandObject::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* OutOfBandObject::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .com.trendmicro.spn.proto.Timestamp expire = 2;
inline bool OutOfBandObject::has_expire() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutOfBandObject::set_has_expire() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutOfBandObject::clear_has_expire() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutOfBandObject::clear_expire() {
  if (expire_ != NULL) expire_->::com::trendmicro::spn::proto::Timestamp::Clear();
  clear_has_expire();
}
inline const ::com::trendmicro::spn::proto::Timestamp& OutOfBandObject::expire() const {
  return expire_ != NULL ? *expire_ : *default_instance_->expire_;
}
inline ::com::trendmicro::spn::proto::Timestamp* OutOfBandObject::mutable_expire() {
  set_has_expire();
  if (expire_ == NULL) expire_ = new ::com::trendmicro::spn::proto::Timestamp;
  return expire_;
}
inline ::com::trendmicro::spn::proto::Timestamp* OutOfBandObject::release_expire() {
  clear_has_expire();
  ::com::trendmicro::spn::proto::Timestamp* temp = expire_;
  expire_ = NULL;
  return temp;
}

// optional string sha1 = 3;
inline bool OutOfBandObject::has_sha1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OutOfBandObject::set_has_sha1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OutOfBandObject::clear_has_sha1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OutOfBandObject::clear_sha1() {
  if (sha1_ != &::google::protobuf::internal::kEmptyString) {
    sha1_->clear();
  }
  clear_has_sha1();
}
inline const ::std::string& OutOfBandObject::sha1() const {
  return *sha1_;
}
inline void OutOfBandObject::set_sha1(const ::std::string& value) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void OutOfBandObject::set_sha1(const char* value) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void OutOfBandObject::set_sha1(const char* value, size_t size) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutOfBandObject::mutable_sha1() {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  return sha1_;
}
inline ::std::string* OutOfBandObject::release_sha1() {
  clear_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha1_;
    sha1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mime_type = 4;
inline bool OutOfBandObject::has_mime_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OutOfBandObject::set_has_mime_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OutOfBandObject::clear_has_mime_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OutOfBandObject::clear_mime_type() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    mime_type_->clear();
  }
  clear_has_mime_type();
}
inline const ::std::string& OutOfBandObject::mime_type() const {
  return *mime_type_;
}
inline void OutOfBandObject::set_mime_type(const ::std::string& value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void OutOfBandObject::set_mime_type(const char* value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void OutOfBandObject::set_mime_type(const char* value, size_t size) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutOfBandObject::mutable_mime_type() {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}
inline ::std::string* OutOfBandObject::release_mime_type() {
  clear_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mime_type_;
    mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 size = 5;
inline bool OutOfBandObject::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OutOfBandObject::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OutOfBandObject::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OutOfBandObject::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 OutOfBandObject::size() const {
  return size_;
}
inline void OutOfBandObject::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Link

// optional string type = 1;
inline bool Link::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Link::type() const {
  return *type_;
}
inline void Link::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Link::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Link::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Link::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Link::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes subject = 2;
inline bool Link::has_subject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Link::set_has_subject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Link::clear_has_subject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Link::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& Link::subject() const {
  return *subject_;
}
inline void Link::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void Link::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void Link::set_subject(const void* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Link::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* Link::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MessageBase

// required bytes subject = 1;
inline bool MessageBase::has_subject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageBase::set_has_subject() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageBase::clear_has_subject() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageBase::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& MessageBase::subject() const {
  return *subject_;
}
inline void MessageBase::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void MessageBase::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void MessageBase::set_subject(const void* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageBase::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* MessageBase::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .com.trendmicro.spn.proto.Link prev_link = 2;
inline int MessageBase::prev_link_size() const {
  return prev_link_.size();
}
inline void MessageBase::clear_prev_link() {
  prev_link_.Clear();
}
inline const ::com::trendmicro::spn::proto::Link& MessageBase::prev_link(int index) const {
  return prev_link_.Get(index);
}
inline ::com::trendmicro::spn::proto::Link* MessageBase::mutable_prev_link(int index) {
  return prev_link_.Mutable(index);
}
inline ::com::trendmicro::spn::proto::Link* MessageBase::add_prev_link() {
  return prev_link_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >&
MessageBase::prev_link() const {
  return prev_link_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >*
MessageBase::mutable_prev_link() {
  return &prev_link_;
}

// repeated .com.trendmicro.spn.proto.Link next_link = 3;
inline int MessageBase::next_link_size() const {
  return next_link_.size();
}
inline void MessageBase::clear_next_link() {
  next_link_.Clear();
}
inline const ::com::trendmicro::spn::proto::Link& MessageBase::next_link(int index) const {
  return next_link_.Get(index);
}
inline ::com::trendmicro::spn::proto::Link* MessageBase::mutable_next_link(int index) {
  return next_link_.Mutable(index);
}
inline ::com::trendmicro::spn::proto::Link* MessageBase::add_next_link() {
  return next_link_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >&
MessageBase::next_link() const {
  return next_link_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Link >*
MessageBase::mutable_next_link() {
  return &next_link_;
}

// repeated .com.trendmicro.spn.proto.OutOfBandObject attachments = 4;
inline int MessageBase::attachments_size() const {
  return attachments_.size();
}
inline void MessageBase::clear_attachments() {
  attachments_.Clear();
}
inline const ::com::trendmicro::spn::proto::OutOfBandObject& MessageBase::attachments(int index) const {
  return attachments_.Get(index);
}
inline ::com::trendmicro::spn::proto::OutOfBandObject* MessageBase::mutable_attachments(int index) {
  return attachments_.Mutable(index);
}
inline ::com::trendmicro::spn::proto::OutOfBandObject* MessageBase::add_attachments() {
  return attachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::OutOfBandObject >&
MessageBase::attachments() const {
  return attachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::OutOfBandObject >*
MessageBase::mutable_attachments() {
  return &attachments_;
}

// -------------------------------------------------------------------

// Message

// required .com.trendmicro.spn.proto.MessageBase msg_base = 1;
inline bool Message::has_msg_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msg_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msg_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msg_base() {
  if (msg_base_ != NULL) msg_base_->::com::trendmicro::spn::proto::MessageBase::Clear();
  clear_has_msg_base();
}
inline const ::com::trendmicro::spn::proto::MessageBase& Message::msg_base() const {
  return msg_base_ != NULL ? *msg_base_ : *default_instance_->msg_base_;
}
inline ::com::trendmicro::spn::proto::MessageBase* Message::mutable_msg_base() {
  set_has_msg_base();
  if (msg_base_ == NULL) msg_base_ = new ::com::trendmicro::spn::proto::MessageBase;
  return msg_base_;
}
inline ::com::trendmicro::spn::proto::MessageBase* Message::release_msg_base() {
  clear_has_msg_base();
  ::com::trendmicro::spn::proto::MessageBase* temp = msg_base_;
  msg_base_ = NULL;
  return temp;
}

// optional bytes derived = 2;
inline bool Message::has_derived() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_derived() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_derived() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_derived() {
  if (derived_ != &::google::protobuf::internal::kEmptyString) {
    derived_->clear();
  }
  clear_has_derived();
}
inline const ::std::string& Message::derived() const {
  return *derived_;
}
inline void Message::set_derived(const ::std::string& value) {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  derived_->assign(value);
}
inline void Message::set_derived(const char* value) {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  derived_->assign(value);
}
inline void Message::set_derived(const void* value, size_t size) {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  derived_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_derived() {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  return derived_;
}
inline ::std::string* Message::release_derived() {
  clear_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = derived_;
    derived_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MessageList

// repeated .com.trendmicro.spn.proto.Message messages = 1;
inline int MessageList::messages_size() const {
  return messages_.size();
}
inline void MessageList::clear_messages() {
  messages_.Clear();
}
inline const ::com::trendmicro::spn::proto::Message& MessageList::messages(int index) const {
  return messages_.Get(index);
}
inline ::com::trendmicro::spn::proto::Message* MessageList::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::com::trendmicro::spn::proto::Message* MessageList::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Message >&
MessageList::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trendmicro::spn::proto::Message >*
MessageList::mutable_messages() {
  return &messages_;
}

// -------------------------------------------------------------------

// ContainerBase

// optional string key = 1;
inline bool ContainerBase::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerBase::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerBase::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerBase::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ContainerBase::key() const {
  return *key_;
}
inline void ContainerBase::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ContainerBase::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ContainerBase::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerBase::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ContainerBase::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string reply_to = 2;
inline bool ContainerBase::has_reply_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerBase::set_has_reply_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerBase::clear_has_reply_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerBase::clear_reply_to() {
  if (reply_to_ != &::google::protobuf::internal::kEmptyString) {
    reply_to_->clear();
  }
  clear_has_reply_to();
}
inline const ::std::string& ContainerBase::reply_to() const {
  return *reply_to_;
}
inline void ContainerBase::set_reply_to(const ::std::string& value) {
  set_has_reply_to();
  if (reply_to_ == &::google::protobuf::internal::kEmptyString) {
    reply_to_ = new ::std::string;
  }
  reply_to_->assign(value);
}
inline void ContainerBase::set_reply_to(const char* value) {
  set_has_reply_to();
  if (reply_to_ == &::google::protobuf::internal::kEmptyString) {
    reply_to_ = new ::std::string;
  }
  reply_to_->assign(value);
}
inline void ContainerBase::set_reply_to(const char* value, size_t size) {
  set_has_reply_to();
  if (reply_to_ == &::google::protobuf::internal::kEmptyString) {
    reply_to_ = new ::std::string;
  }
  reply_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerBase::mutable_reply_to() {
  set_has_reply_to();
  if (reply_to_ == &::google::protobuf::internal::kEmptyString) {
    reply_to_ = new ::std::string;
  }
  return reply_to_;
}
inline ::std::string* ContainerBase::release_reply_to() {
  clear_has_reply_to();
  if (reply_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reply_to_;
    reply_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .com.trendmicro.spn.proto.MessageList message_list = 3;
inline bool ContainerBase::has_message_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContainerBase::set_has_message_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContainerBase::clear_has_message_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContainerBase::clear_message_list() {
  if (message_list_ != NULL) message_list_->::com::trendmicro::spn::proto::MessageList::Clear();
  clear_has_message_list();
}
inline const ::com::trendmicro::spn::proto::MessageList& ContainerBase::message_list() const {
  return message_list_ != NULL ? *message_list_ : *default_instance_->message_list_;
}
inline ::com::trendmicro::spn::proto::MessageList* ContainerBase::mutable_message_list() {
  set_has_message_list();
  if (message_list_ == NULL) message_list_ = new ::com::trendmicro::spn::proto::MessageList;
  return message_list_;
}
inline ::com::trendmicro::spn::proto::MessageList* ContainerBase::release_message_list() {
  clear_has_message_list();
  ::com::trendmicro::spn::proto::MessageList* temp = message_list_;
  message_list_ = NULL;
  return temp;
}

// optional .com.trendmicro.spn.proto.OutOfBandObject message_list_ref = 4;
inline bool ContainerBase::has_message_list_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContainerBase::set_has_message_list_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContainerBase::clear_has_message_list_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContainerBase::clear_message_list_ref() {
  if (message_list_ref_ != NULL) message_list_ref_->::com::trendmicro::spn::proto::OutOfBandObject::Clear();
  clear_has_message_list_ref();
}
inline const ::com::trendmicro::spn::proto::OutOfBandObject& ContainerBase::message_list_ref() const {
  return message_list_ref_ != NULL ? *message_list_ref_ : *default_instance_->message_list_ref_;
}
inline ::com::trendmicro::spn::proto::OutOfBandObject* ContainerBase::mutable_message_list_ref() {
  set_has_message_list_ref();
  if (message_list_ref_ == NULL) message_list_ref_ = new ::com::trendmicro::spn::proto::OutOfBandObject;
  return message_list_ref_;
}
inline ::com::trendmicro::spn::proto::OutOfBandObject* ContainerBase::release_message_list_ref() {
  clear_has_message_list_ref();
  ::com::trendmicro::spn::proto::OutOfBandObject* temp = message_list_ref_;
  message_list_ref_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LogInfo

// required string type = 1;
inline bool LogInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& LogInfo::type() const {
  return *type_;
}
inline void LogInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LogInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LogInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* LogInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 version = 2;
inline bool LogInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 LogInfo::version() const {
  return version_;
}
inline void LogInfo::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required int64 timestamp = 3;
inline bool LogInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogInfo::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LogInfo::timestamp() const {
  return timestamp_;
}
inline void LogInfo::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required string original_exchange = 4;
inline bool LogInfo::has_original_exchange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogInfo::set_has_original_exchange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogInfo::clear_has_original_exchange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogInfo::clear_original_exchange() {
  if (original_exchange_ != &::google::protobuf::internal::kEmptyString) {
    original_exchange_->clear();
  }
  clear_has_original_exchange();
}
inline const ::std::string& LogInfo::original_exchange() const {
  return *original_exchange_;
}
inline void LogInfo::set_original_exchange(const ::std::string& value) {
  set_has_original_exchange();
  if (original_exchange_ == &::google::protobuf::internal::kEmptyString) {
    original_exchange_ = new ::std::string;
  }
  original_exchange_->assign(value);
}
inline void LogInfo::set_original_exchange(const char* value) {
  set_has_original_exchange();
  if (original_exchange_ == &::google::protobuf::internal::kEmptyString) {
    original_exchange_ = new ::std::string;
  }
  original_exchange_->assign(value);
}
inline void LogInfo::set_original_exchange(const char* value, size_t size) {
  set_has_original_exchange();
  if (original_exchange_ == &::google::protobuf::internal::kEmptyString) {
    original_exchange_ = new ::std::string;
  }
  original_exchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_original_exchange() {
  set_has_original_exchange();
  if (original_exchange_ == &::google::protobuf::internal::kEmptyString) {
    original_exchange_ = new ::std::string;
  }
  return original_exchange_;
}
inline ::std::string* LogInfo::release_original_exchange() {
  clear_has_original_exchange();
  if (original_exchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = original_exchange_;
    original_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string event = 5;
inline bool LogInfo::has_event() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogInfo::set_has_event() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogInfo::clear_has_event() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogInfo::clear_event() {
  if (event_ != &::google::protobuf::internal::kEmptyString) {
    event_->clear();
  }
  clear_has_event();
}
inline const ::std::string& LogInfo::event() const {
  return *event_;
}
inline void LogInfo::set_event(const ::std::string& value) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void LogInfo::set_event(const char* value) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(value);
}
inline void LogInfo::set_event(const char* value, size_t size) {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  event_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_event() {
  set_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    event_ = new ::std::string;
  }
  return event_;
}
inline ::std::string* LogInfo::release_event() {
  clear_has_event();
  if (event_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_;
    event_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string prefix = 6;
inline bool LogInfo::has_prefix() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogInfo::set_has_prefix() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogInfo::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogInfo::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& LogInfo::prefix() const {
  return *prefix_;
}
inline void LogInfo::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void LogInfo::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void LogInfo::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* LogInfo::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Container

// required .com.trendmicro.spn.proto.ContainerBase container_base = 1;
inline bool Container::has_container_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_container_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_container_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_container_base() {
  if (container_base_ != NULL) container_base_->::com::trendmicro::spn::proto::ContainerBase::Clear();
  clear_has_container_base();
}
inline const ::com::trendmicro::spn::proto::ContainerBase& Container::container_base() const {
  return container_base_ != NULL ? *container_base_ : *default_instance_->container_base_;
}
inline ::com::trendmicro::spn::proto::ContainerBase* Container::mutable_container_base() {
  set_has_container_base();
  if (container_base_ == NULL) container_base_ = new ::com::trendmicro::spn::proto::ContainerBase;
  return container_base_;
}
inline ::com::trendmicro::spn::proto::ContainerBase* Container::release_container_base() {
  clear_has_container_base();
  ::com::trendmicro::spn::proto::ContainerBase* temp = container_base_;
  container_base_ = NULL;
  return temp;
}

// optional bytes derived = 2;
inline bool Container::has_derived() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_derived() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_derived() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_derived() {
  if (derived_ != &::google::protobuf::internal::kEmptyString) {
    derived_->clear();
  }
  clear_has_derived();
}
inline const ::std::string& Container::derived() const {
  return *derived_;
}
inline void Container::set_derived(const ::std::string& value) {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  derived_->assign(value);
}
inline void Container::set_derived(const char* value) {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  derived_->assign(value);
}
inline void Container::set_derived(const void* value, size_t size) {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  derived_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_derived() {
  set_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    derived_ = new ::std::string;
  }
  return derived_;
}
inline ::std::string* Container::release_derived() {
  clear_has_derived();
  if (derived_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = derived_;
    derived_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .com.trendmicro.spn.proto.LogInfo log_info = 3;
inline bool Container::has_log_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_log_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_log_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_log_info() {
  if (log_info_ != NULL) log_info_->::com::trendmicro::spn::proto::LogInfo::Clear();
  clear_has_log_info();
}
inline const ::com::trendmicro::spn::proto::LogInfo& Container::log_info() const {
  return log_info_ != NULL ? *log_info_ : *default_instance_->log_info_;
}
inline ::com::trendmicro::spn::proto::LogInfo* Container::mutable_log_info() {
  set_has_log_info();
  if (log_info_ == NULL) log_info_ = new ::com::trendmicro::spn::proto::LogInfo;
  return log_info_;
}
inline ::com::trendmicro::spn::proto::LogInfo* Container::release_log_info() {
  clear_has_log_info();
  ::com::trendmicro::spn::proto::LogInfo* temp = log_info_;
  log_info_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace spn
}  // namespace trendmicro
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SpnMessage_2eproto__INCLUDED
